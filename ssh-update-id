#!/bin/bash
# ssh-update-id -i ~/.ssh/mykey -o ~/.ssh/oldkey  user@host  [user2@host2 ...]

# Enable strict mode for safety and robustness:
# -e: exit immediately if a command exits with a non-zero status
# -u: treat unset variables as an error and exit immediately
# -o pipefail: return the exit status of the first command in a pipeline that fails
set -euo pipefail

###############################################################################
# Parse and check params
###############################################################################
usage() {
    if [ -n "${1:-}" ]; then
        printf "\n%s\n\n" "$1"
    fi
    echo "Usage: $0 -i <newKey> -o <oldKey> user@host" >&2
    exit 1
}

newKey=""
oldKey=""

while getopts i:o:? opt; do
    case $opt in
        i) newKey="$OPTARG" ;;
        o) oldKey="$OPTARG" ;;
        ?) usage ;;
    esac
done
shift $((OPTIND - 1))

targetHosts=("$@")

# Check parameters
if [[ -z "$newKey" || -z "$oldKey" ]]; then
    usage "Error: You must provide old and new keys"
fi

# Check targetHost
if [[ "${#targetHosts[@]}" -eq 0 ]]; then
    usage "Error: You must provide at least one targetHost"
fi

# Check key files
[[ -f "$newKey" ]] || usage "New key file not found: $newKey"
[[ -f "$oldKey" ]] || usage "Old key file not found: $oldKey"


# Generate public keys
oldPubKey=$(ssh-keygen -y -f "$oldKey" 2>/dev/null | cut -d' ' -f1,2) || usage "Invalid old private key"
newPubKeyFull=$(ssh-keygen -y -f "$newKey" 2>/dev/null) || usage "Invalid new private key"
newPubKey=$(echo "$newPubKeyFull" | cut -d' ' -f1,2)

# Create temp file with new key once
tempKeyFile=$(mktemp)
echo "$newPubKeyFull" > "$tempKeyFile"

# Check if keys are the same
if [[ "$oldPubKey" == "$newPubKey" ]]; then
    usage "New key and old key are identical. Aborting to prevent self-replacement."
fi


###############################################################################
# Perform update for each target host
###############################################################################
for targetHost in "${targetHosts[@]}"; do
    echo -e "\nUpdating keys for: $targetHost"

    # Validate targetHost format
    if [[ "$targetHost" != *@* ]]; then
        echo "Error: targetHost '$targetHost' must be in format user@host"
        continue
    fi

    tmpKeysFile=$(mktemp /tmp/authorized_keys.XXXXXX)

    # Copy current authorized_keys
    scp -q -i "$oldKey" "$targetHost:~/.ssh/authorized_keys" "$tmpKeysFile" || touch "$tmpKeysFile"

    # Strip comments before checking for key presence
    cleanedKeys=$(cut -d' ' -f1,2 "$tmpKeysFile")

    # Check if new key already exists (ignoring comments)
    if grep -qF "$newPubKey" <<< "$cleanedKeys"; then
        echo "Warning: The authorized_keys on $targetHost already contains the new key. Skipping."
        rm -f "$tmpKeysFile"
        continue
    fi

    # Add full new public key (including comment) using old key
	scp -q -i "$oldKey" "$tempKeyFile" "$targetHost:~/.ssh/temp_newkey.pub"
    ssh -i "$oldKey" "$targetHost" "umask 077 && cat ~/.ssh/temp_newkey.pub >> ~/.ssh/authorized_keys && rm ~/.ssh/temp_newkey.pub"
	
	
	# Test connectivity with new key before removing the old one
    if ssh -q -o BatchMode=yes -i "$newKey" "$targetHost" "true"; then
        # Remove old public key using new key (ignoring comment)
        cmd="umask 077 && grep -vF \"$oldPubKey\" ~/.ssh/authorized_keys > ~/.ssh/tmp_keys && mv ~/.ssh/tmp_keys ~/.ssh/authorized_keys"
        ssh -i "$newKey" "$targetHost" "$cmd"
        echo "Old key removed successfully on $targetHost"
    else
        echo "Error: Could not connect to $targetHost using the new key. Old key NOT removed."
    fi
	
    # Clean up
    rm -f "$tmpKeysFile"

    echo "Public key updated successfully on $targetHost"
done

# Remove temp key file
rm -f "$tempKeyFile"


